
-= Prerequisites =-
- GHC 7.4.x (known to work with 7.4.1)
- QuickCheck 2.5
- make (can be found as part of MinGW, in ...\MinGW\msys\1.0\bin under Windows)
- other UNIX utilities like echo, rm, etc.
- Haskell package: CmdArgs 0.9.5 and above (available with 'cabal install cmdargs')
- Haskell package: concurrent-extra (available with 'cabal install concurrent-extra')

-= Contents =-

README

Makefile
Makefile.common

alloc/  
	AllocTest.hs
	MulticoreAlloc.hs
	SinglecoreAlloc.hs

tmu/    -- Tag Management Unit 
        TMUAbstract.hs    : definition of the abstract machine
	TMUAbstractGen.hs : program random generation for the abstract machine
	TMUAbstractObs.hs : observable classes and shrinking variations
	TMUConcrete.hs    : definition of the concrete machine
	TMUDriver.hs      : experiment set up, top level properties, main
	TMUFlags.hs       : various flags configuration of a machine
	TMUInstr.hs       : ISA
	TMULabels.hs      : label systems, and observations
	TMULayer.hs       : correspondence between abstract/concrete machine
	TMUObservable.hs  : observable classes

common/ -- Common definitions, and helpers
	Aggregate.hs
	CollectTests.hs         : collecting properties to test
	Machine.hs              : common definitions for generic "machines"
	Pretty.hs               : pretty printing
	THAutoLift.hs           
	THLiftOrphans.hs        
	THVersionCompat.hs      
	Trace.hs                : execution traces
	Util.hs                 : misc. helpers

-= Building =-

Run "make" in the top directory

-= Using ghci =-

All you need to do is invoke ghci (e.g. C-c C-l in Emacs if using
haskell-mode default key bindings) and the .ghci files will take care
of the rest.

On Linux you might have permission problems (you might see "WARNING:
.ghci is writable by someone else, IGNORING!" when starting ghci), in
which case you need to make sure that this dir, its subdirs and the
.ghci files inside are not group readable. A command like
> chmod -R g-w .
should usually solve the problem.

-= Running the TMU driver from command line =-

You may run the TMU driver from the command line with: 
    ./TMUDriver
This will run with the default configuration, shown in TMUFlags.hs
However you may override one of the options manually as well -- for
instance:
   ./TMUDriver --gen-strategy=GenNaive --tmu-tests=10000
or 
   ./TMUDriver --gen-strategy=GenByExec --tmu-tests=30000

All values (and names for named options) are specified in TMUFlags.hs. Finally,
you may run:
   ./TMUDriver --help
to see a list of available options.

-= Basic profiling of test generation =-

TMUDriver contains flags that can profile tests for some 
basic statistics. Namely, the 

  --tmu-prop-test=PropJustProfileLengths
and
  --tmu-prop-test=PropJustProfileWF

run profiling on tests with the current configuration. The former is 
profiling execution lenghts, the latter is profiling the reasons for 
termination. You may use --tmu-tests to determine the number of tests, 
or --gen-strategy to determine under which strategy you want to profile, etc.

-= Bulk testing and profiling =-

Some new options have been introduced that help profile/test in the bulk.

Namely, you may want to give a string argument to --ifc-semantics, e.g.:
   --ifc-semantics="[IfcBugAddNoTaint,IfcBugStoreNoTaint]"
which will iterate over these two buggy behaviors. The --ifc-semantics
flag stands for a list of behaviours you would like to test. For convenience
there exists a wildcard value:
   --ifc-semantics="*"
which you may use to iterate over all bugs. 

Moreover, each experiment can be repeated for:
   --tmu-attempts 
times. 

When testing you may want to suppress printing information from the 
actual counterexample, which you can do with:
   --show-counterexamples=False

Here is an example usage:

./TMUDriver --ifc-semantics="*" 
            --gen-strategy=GenByExec 
            --tmu-tests=100 
            --tmu-attempts=3 
            --show-counterexamples=False

Iterates over all bugs using GenByExec, doing 3 QC invocations each with 
100 tests, not showing counterexamples. It will print out average results 
in some format [DV:TODO]


-= Coding syntax rules =-

The rationale for these rules is that they make refactoring easier.

In ghci, warnings will be raised:
- if a top-level declaration is missing a type signature
- if a tab is present
- if a do block uses a value of type m A, for A â‰  (), without binding
  it to a value
- if you have an incomplete set of pattern matches

For instance,
Prelude> let j (Just a) = a
<interactive>:2:5:
    Warning: Pattern match(es) are non-exhaustive
             In an equation for `j': Patterns not matched: Nothing

At compile-time, these warnings are errors: you're forced to stick to
these coding standards.